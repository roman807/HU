#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Roman Moser, 9/10/19

"""
CISC 601 -Scientific Computing II
Implementation of a genetic algorithm for the knapsack problem
"""

import numpy as np
import pandas as pd
import random


class Setup():
    """
    define attributes and methods used for both, the Genetic Algorithm and 
    the Brute Force approach
    """
    def __init__(self, weights, profits, max_total_weight):
        self.weights = weights
        self.profits = profits
        self.max_total_weight = max_total_weight
        self.population_size = len(weights)

    def fitness(self, array):
        penalty = 0
        if sum(np.array(array) * self.weights) > self.max_total_weight:
            penalty = sum(np.array(array) * self.weights) - self.max_total_weight
        return np.sum(np.array(array) * np.array(self.profits)) - penalty
    
    def random_pool(self):
        pool = pd.DataFrame(index=range(self.population_size), columns = ['chromosome', 'fitness'])
        for i in range(self.population_size):
            chromosome = [np.round(k) for k in np.random.rand(self.population_size)]
            pool.iloc[i, :] = \
                np.array([chromosome, self.fitness(chromosome)])
            pool.sort_values('fitness', inplace=True, ascending=False)
            pool.reset_index(drop=True, inplace=True)
        return pool
    
    def best_solution(self, pool):
        pool.sort_values('fitness', inplace=True, ascending=False)
        pool.reset_index(drop=True, inplace=True)
        for i in pool.index:
            if self.is_feasible(pool.loc[i, 'chromosome']):
                return pool.loc[i, 'chromosome'], pool.loc[i, 'fitness']
        print('no feasible solution found')
        return [], []
    
    def is_feasible(self, chromosome):
        if sum(np.array(chromosome) * self.weights) <= self.max_total_weight:
            return True
        else:
            return False

class GeneticAlgorithm(Setup):
    """
    Genetic Algorithm: each new generation is generated by 50% mating of the
    top 50% parent chromosomes of the previous generation and 50% mutations
    (mutate 1 chromosom) of the top 50% parent chromosomes 
    """
    def __init__(self, weights, profits, max_total_weight, total_generations):
        Setup.__init__(self, weights, profits, max_total_weight)
        self.total_generations = total_generations
        self.fitness_dict = {}
        self.max_fitness = 0

    def get_mating_pool(self, pool):
        return pool.iloc[:int(self.population_size / 2), :]
    
    def mate(self, mating_pool):
        chromosomes_pool_1 = mating_pool.sample(frac=1).reset_index(drop=True)['chromosome']
        chromosomes_pool_2 = mating_pool.sample(frac=1).reset_index(drop=True)['chromosome']
        new_members = []
        for chromosomes_pool in (chromosomes_pool_1, chromosomes_pool_2):
            i = 0
            while i < len(chromosomes_pool_1) - 1:
                mate_1, mate_2 = chromosomes_pool[i], chromosomes_pool[i + 1]
                new_member = []
                for k in range(len(mate_1)):
                    new_member.append(random.choice([mate_1[k], mate_2[k]]))
                i += 2
                new_members.append(new_member)
        return new_members

    def mutate(self, mating_pool, n_mutations=1):
        new_members = []
        for chromosome in mating_pool['chromosome']:
            index_mutate = np.random.randint(len(chromosome), size=n_mutations)
            for i in index_mutate:
                chromosome[i] = 1 - chromosome[i]
            new_members.append(chromosome)
        return new_members
    
    def get_new_pool(self, members_children, members_mutated):
        population_size = len(members_children) + len(members_mutated)
        pool = pd.DataFrame(index=range(population_size), columns = ['chromosome', 'fitness'])
        i = 0
        for chromosomes in (members_children, members_mutated):
            for chromosome in chromosomes:
                pool.iloc[i, :] = \
                    np.array([chromosome, self.fitness(chromosome)])
                i += 1
        pool.sort_values('fitness', inplace=True, ascending=False)
        pool.reset_index(drop=True, inplace=True)
        return pool
    
    def genetic_algorithm(self, pool, generation=0):
        if generation == self.total_generations:
            return pool
        mating_pool = self.get_mating_pool(pool)
        members_children = self.mate(mating_pool)
        members_mutated = self.mutate(mating_pool)
        pool = self.get_new_pool(members_children, members_mutated)
        _, best_solution_ = self.best_solution(pool)
        self.max_fitness = max(best_solution_, self.max_fitness)
        self.fitness_dict[generation] = self.max_fitness
        generation += 1
        return self.genetic_algorithm(pool, generation)
    
        
class BruteForce(Setup):
    """
    Brute Force Algorithm: generate random pools of chromosomes (same population
    size as for genetic algorithm)
    """  
    def __init__(self, weights, profits, max_total_weight, total_generations):
        Setup.__init__(self, weights, profits, max_total_weight)
        self.total_generations = total_generations
        self.best_solutions = {}
        self.max_fitness = 0
        
    def brute_force_algorithm(self):
        for i in range(self.total_generations):
            pool = self.random_pool()
            _, best_solution_ = self.best_solution(pool)
            self.max_fitness = max(best_solution_, self.max_fitness)
            self.best_solutions[i] = self.max_fitness
